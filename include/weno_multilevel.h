#ifndef WENO_MULTILEVEL_H_
#define WENO_MULTILEVEL_H_

#include <vector>
#include <valarray>
#include <algorithm>
#include <numeric>

#include "lapacke.h"
#include "integral.h"
#include <assert.h>

using namespace std;

using point        = valarray<double>;
using point_index  = valarray<int>;
using index_set    = vector<point_index>;
using points_set   = vector<point>;
using stencil      = vector<points_set>;

/*
 *Containing essential information about mesh.
 */
typedef struct {

    int dim;

    vector<int> localsize;   // Local chunck size without ghost layer
    vector<int> globalsize;  // global chunck size without ghost layer
    vector<int> ghost_cell;  // size of ghost layer of cell
    vector<int> ghost_vertx; // size of ghost layer of node

    vector< point > lmesh; 
 
    double** localval;

    // Corner index within a single element
    index_set corner_index_1D {{0}, {1}};
    index_set corner_index_2D {{0,0},{1,0},{1,1},{0,1}};
    index_set corner_index_3D {{0,0,0},{1,0,0},{1,1,0},{0,1,0},
                               {0,0,1},{1,0,1},{1,1,1},{0,1,1}};

} MeshInfo;

template <class T>
class myStencil{
    public:
        myStencil(size_t x): X(x), stencilSize(x) {};
        myStencil(size_t x, size_t y): X(x), Y(y), stencilSize(x*y) {};
        myStencil(size_t x, size_t y, size_t z): X(x), Y(y), Z(z), stencilSize(x*y*z) {};

        void CreateStencil() {stencil.resize(stencilSize);}

        T &operator()(size_t i){
            return stencil[i];
        }

        T &operator()(size_t i, size_t j){
            return stencil[i+j*X];
        }

        T &operator()(size_t i, size_t j, size_t k){
            return stencil[i+j*X+k*X*Y];
        }

        vector<T> GetStencil() {return stencil;}

    private:
        size_t X;
        size_t Y;
        size_t Z; 
        size_t stencilSize;
        vector<T> stencil;
};

/*
 *Define Stencil information used by WENO reconstruction.
 */
class WenoStencil{
    public:
        WenoStencil(MeshInfo* mi, const int rangex[2], point_index& target);
        WenoStencil(MeshInfo* mi, const int rangex[2], const int rangey[2], point_index& target);
        WenoStencil(MeshInfo* mi, const int rangex[2], const int rangey[2],
                                  const int rangez[2], point_index& target);

        ~WenoStencil() {delete polyn;};

        // Create coefficients for basis polynomials and
        // corresponding coefficients for derivative of 
        // basis polynomials. 
        void CreateBasisPolyn(MeshInfo* mi);

        // Create smoothness indicator at the very beginning
        void CreateSigma(MeshInfo*& mi);   // Classical Jiang and Shu Smoothness Indicator

        // Update smoothness indicator after each time step
        void UpdateSigma(MeshInfo*& mi);

        // Check computed results
        void CheckWenoStencil();
        void PrintBasisPolyn();

    private:

        double * CreateBasisPolynDeriv(int xdegree, int ydegree, int k);

        point stencil_center;

        vector<point> center_cell_corners;

        int stencil_size;

        void GenerateStencil(int dim, vector<point_index>& range, point_index& target);

        double h;

        // Basis polynomial order
        vector<int> polyn_order;

        // Stencil index set generated by index_range
        index_set stencil_index_set;

        // Coefficients of basis polynomial based on given stencil and order.
        double * polyn;

        // Smoothness indicator.
        double sigma;
};

class WenoReconst{
    public:
        WenoReconst(vector< const int* >& index_ranges);

        ~WenoReconst();

        void GetLinearWeights();

        void CreateNonlinWeights();

        double PointReconstruction();

    private:

        double * lin_weight;

        double * omega;

        double * nonln_weight;

};

#endif
